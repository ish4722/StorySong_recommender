# -*- coding: utf-8 -*-
"""emotion_detector.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/18QBgs22MkXq73x-kQLTInQknL0uduB45
"""

!mkdir -p ~/.kaggle
!cp kaggle.json ~/.kaggle/

!kaggle datasets download -d msambare/fer2013

import zipfile
zip_ref = zipfile.ZipFile("/content/fer2013.zip", 'r')
zip_ref.extractall("/content")
zip_ref.close()

import tensorflow as tf
from tensorflow.keras.preprocessing.image import ImageDataGenerator
import numpy as np
import matplotlib.pyplot as plt
import cv2

# Set the paths for your training and validation data
train_dir = '/content/train'
val_dir = '/content/test'

# Image data generator for training
train_datagen = ImageDataGenerator(
    rescale=1./255,
    rotation_range=30,
    shear_range=0.2,
    zoom_range=0.2,
    horizontal_flip=True,
    fill_mode='nearest'
)

val_datagen = ImageDataGenerator(rescale=1./255)

# Load and iterate training dataset
train_generator = train_datagen.flow_from_directory(
    train_dir,
    target_size=(48, 48),
    color_mode='grayscale',
    batch_size=64,
    class_mode='categorical',
    shuffle=True
)

# Load and iterate validation dataset
validation_generator = val_datagen.flow_from_directory(
    val_dir,
    target_size=(48, 48),
    color_mode='grayscale',
    batch_size=64,
    class_mode='categorical',
    shuffle=False
)

import numpy as np
import argparse
import matplotlib.pyplot as plt
import cv2
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Dropout, Flatten
from tensorflow.keras.layers import Conv2D
from tensorflow.keras.optimizers import Adam
from tensorflow.keras.layers import MaxPooling2D
from tensorflow.keras.preprocessing.image import ImageDataGenerator
model = Sequential()

model.add(Conv2D(32, kernel_size=(3, 3), activation='relu', input_shape=(48,48,1)))
model.add(Conv2D(64, kernel_size=(3, 3), activation='relu'))
model.add(MaxPooling2D(pool_size=(2, 2)))
model.add(Dropout(0.25))

model.add(Conv2D(128, kernel_size=(3, 3), activation='relu'))
model.add(MaxPooling2D(pool_size=(2, 2)))
model.add(Conv2D(128, kernel_size=(3, 3), activation='relu'))
model.add(MaxPooling2D(pool_size=(2, 2)))
model.add(Dropout(0.25))

model.add(Flatten())
model.add(Dense(1024, activation='relu'))
model.add(Dropout(0.5))
model.add(Dense(7, activation='softmax'))

num_train = 28709
batch_size = 64
num_epoch = 50
num_val = 7178
model.compile(loss='categorical_crossentropy',
              optimizer=Adam(learning_rate=0.0001, decay=1e-6),
              metrics=['accuracy'])
# Use model.fit instead of model.fit_generator
model_info = model.fit(
            train_generator,
            steps_per_epoch=num_train // batch_size,
            epochs=num_epoch,
            validation_data=validation_generator,
            validation_steps=num_val // batch_size)

import pickle
pickle.dump(model, open('/content/emotion_detector', 'wb'))



# prompt: plot the model

from tensorflow.keras.utils import plot_model
plot_model(model, to_file='model.png', show_shapes=True, show_layer_names=True)

# prompt: plot  a graph with accuracy and epochs

import matplotlib.pyplot as plt
# Plot accuracy
plt.plot(model_info.history['accuracy'])
plt.plot(model_info.history['val_accuracy'])
plt.title('Model Accuracy')
plt.ylabel('Accuracy')
plt.xlabel('Epoch')
plt.legend(['Train', 'Validation'], loc='upper left')
plt.show()

emotion=pickle.load(open('/content/emotion_detector', 'rb'))

# prompt: predict emotion of a input img

import numpy as np
# Assuming 'image_path' is the path to your input image
image_path = '# Replace with your image path'

img = cv2.imread(image_path)
gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)
resized_img = cv2.resize(gray, (48, 48))
img_array = np.expand_dims(resized_img, axis=0)
img_array = np.expand_dims(img_array, axis=-1)  # Add channel dimension
img_array = img_array.astype('float32') / 255.0  # Normalize

prediction = emotion.predict(img_array)
predicted_class = np.argmax(prediction)

# Map predicted class to emotion label
emotion_labels = ['Angry', 'Disgust', 'Fear', 'Happy', 'Neutral', 'Sad', 'Surprise']
predicted_emotion = emotion_labels[predicted_class]

print("Predicted Emotion:", predicted_emotion)